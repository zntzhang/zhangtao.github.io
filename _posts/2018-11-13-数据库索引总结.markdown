---
layout:  post
title:   数据库索引总结
date:   2020-03-06 15:52
author:  "张涛"
header-img: "img/post-bg-2015.jpg"
catalog:   false
tags:
    - 数据库
---
#  为什么要使用索引？

  1. 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。 
  2. 可以大大加快 数据的检索速度（大大减少的检索的数据量），这也是创建索引的最主要的原因。 
  3. 帮助服务器避免排序和临时表 
  4. 将随机IO变为顺序IO 
  5. 可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。 

#  索引这么多优点，为什么不对表中的每一个列创建一个索引呢？

  1. 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。 
  2. 索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。 
  3. 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。 

#  索引是如何提高查询速度的？

将无序的数据变成相对有序的数据（就像查目录一样）

#  使用索引的注意事项

  1. 在经常需要搜索的列上，可以加快搜索的速度； 
  2. 在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。 
  3. 在经常需要排序的列上创 建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间； 
  4. 对于中到大型表索引都是非常有效的，但是特大型表的话维护开销会很大，不适合建索引 
  5. 在经常用在连接的列上，这 些列主要是一些外键，可以加快连接的速度； 
  6. 避免 where 子句中对宇段施加函数，这会造成无法命中索引。 
  7. 在使用InnoDB时使用与业务无关的自增主键作为主键，即使用逻辑主键，而不要使用业务主键。 
  8. 将打算加索引的列设置为 NOT NULL ，否则将导致引擎放弃使用索引而进行全表扫描 
  9. 删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗 MySQL 5.7,可以通过查询 sys 库的 chema_unused_indexes 视图来查询哪些索引从未被使用 
  10. 在使用 limit offset 查询缓慢时，可以借助索引来提高性能 

#  Mysql索引主要使用的两种数据结构

##  哈希索引

对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。

##  BTree索引

Mysql的BTree索引使用的是B树中的B+Tree。但对于主要的两种存储引擎（MyISAM和InnoDB）的实现方式是不同的。

#  MyISAM和InnoDB实现BTree索引方式的区别

**MyISAM** :
B+Tree叶节点的data域存放的是数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其 data
域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。

**InnoDB** :
其数据文件本身就是索引文件。相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）”，而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，在走一遍主索引。
因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。 PS：整理自《Java工程师修炼之道》

#  覆盖索引介绍

##  什么是覆盖索引

如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称  
之为“覆盖索引”。我们知道在InnoDB存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次。这样就会比较慢  
覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！

##  覆盖索引使用实例

现在我创建了索引(username,age)，在查询数据的时候：select username , age from user where username
= ‘Java’ and age = 22。要查询出的列在叶子节点都存在！所以，就不用回表。

##  选择索引和编写利用这些索引的查询的3个原则

  1. 单行访问是很慢的。特别是在机械硬盘存储中(SSD的随机I/O要快很多，不过这   
一点仍然成立）。如果服务器从存储中读取一个数据块只是为了获取其中一行，那么  
就浪费了很多工作。最好读取的块中能包含尽可能多所需要的行。使用索引可以创  
建位置引，用以提升效率。

  2. 按顺序访问范围数据是很快的，这有两个原因。第一，顺序1/0不需要多次磁盘寻道，所以比随机I/O要快很多（特别是对机械硬盘）。第二，如果服务器能够按需要顺序读取数据，那么就不再需要额外的排序操作，并且GROUPBY查询也无须再做排序和   
将行按组进行聚合计算了。

  3. 索引覆盖查询是很快的。如果一个索引包含了查询需要的所有列，那么存储引擎就   
不需要再回表查找行。这避免了大量的单行访问，而上面的第1点已经写明单行访  
问是很慢的。

#  联合索引-最左前缀原则

##  什么是联合索引

MySQL中的索引可以以一定顺序引用多列，这种索引叫作联合索引  
如User表的name和city加联合索引就是(name,city)

##  最左前缀原则

最左前缀原则指的是，如果查询的时候查询条件精确匹配索引的左边连续一列或几列，则此列就可以被用到

    
    
    select * from user where name=xx and city=xx ; ／／可以命中索引
    select * from user where name=xx ; // 可以命中索引
    select * from user where city=xx; // 无法命中索引 
    

这里需要注意的是，查询的时候如果两个条件都用上了，但是顺序不同，如 city= xx and name
＝xx，那么现在的查询引擎会自动优化为匹配联合索引的顺序，这样是能够命中索引的.

由于最左前缀原则，在创建联合索引时，索引字段的顺序需要考虑字段值去重之后的个数，较多的放前面。ORDERBY子句也遵循此规则。

##  注意避免冗余索引

冗余索引指的是索引的功能相同，能够命中 就肯定能命中 ，那么 就是冗余索引如（name,city ）和（name
）这两个索引就是冗余索引，能够命中后者的查询肯定是能够命中前者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。

MySQLS.7 版本后，可以通过查询 sys 库的 schemal_r dundant_indexes 表来查看冗余索引

